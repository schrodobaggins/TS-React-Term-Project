{"ast":null,"code":"export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n  return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n    await Promise.all(audioNodeConnections.activeInputs.map((connections, input) => Array.from(connections).map(async _ref => {\n      let [source, output] = _ref;\n      const audioNodeRenderer = getAudioNodeRenderer(source);\n      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n      const destination = audioNode.context.destination;\n\n      if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n        renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n      }\n    })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n  };\n};","map":{"version":3,"sources":["../../../src/factories/render-inputs-of-audio-node.ts"],"names":[],"mappings":"AAGA,OAAO,MAAM,6BAA6B,GAAoC,CAC1E,uBAD0E,EAE1E,oBAF0E,EAG1E,cAH0E,KAI1E;AACA,SAAO,OAAO,SAAP,EAAkB,yBAAlB,EAA6C,eAA7C,KAAgE;AACnE,UAAM,oBAAoB,GAAG,uBAAuB,CAAC,SAAD,CAApD;AAEA,UAAM,OAAO,CAAC,GAAR,CACF,oBAAoB,CAAC,YAArB,CACK,GADL,CACS,CAAC,WAAD,EAAc,KAAd,KACD,KAAK,CAAC,IAAN,CAAW,WAAX,EAAwB,GAAxB,CAA4B,cAA2B;AAAA,UAApB,CAAC,MAAD,EAAS,MAAT,CAAoB;AACnD,YAAM,iBAAiB,GAAG,oBAAoB,CAAC,MAAD,CAA9C;AACA,YAAM,uBAAuB,GAAG,MAAM,iBAAiB,CAAC,MAAlB,CAAyB,MAAzB,EAAiC,yBAAjC,CAAtC;AACA,YAAM,WAAW,GAAoD,SAAS,CAAC,OAAV,CAAkB,WAAvF;;AAEA,UAAI,CAAC,cAAc,CAAC,MAAD,CAAf,KAA4B,SAAS,KAAK,WAAd,IAA6B,CAAC,cAAc,CAAC,SAAD,CAAxE,CAAJ,EAA0F;AACtF,QAAA,uBAAuB,CAAC,OAAxB,CAAgC,eAAhC,EAAiD,MAAjD,EAAyD,KAAzD;AACH;AACJ,KARD,CAFR,EAYK,MAZL,CAYY,CAAC,oBAAD,EAAuB,iBAAvB,KAA6C,CAAC,GAAG,oBAAJ,EAA0B,GAAG,iBAA7B,CAZzD,EAY0G,EAZ1G,CADE,CAAN;AAeH,GAlBD;AAmBH,CAxBM","sourceRoot":"","sourcesContent":["export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        await Promise.all(audioNodeConnections.activeInputs\n            .map((connections, input) => Array.from(connections).map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n            const destination = audioNode.context.destination;\n            if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n            }\n        }))\n            .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n    };\n};\n//# sourceMappingURL=render-inputs-of-audio-node.js.map"]},"metadata":{},"sourceType":"module"}